/**
 * Polygon API
 * The future of fintech.
 *
 * OpenAPI spec version: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.polygon.io';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AggResponse {
    /**
    * Ticker symbol requested
    */
    'ticker': string;
    /**
    * Status of the response
    */
    'status': string;
    /**
    * If this response was adjusted for splits
    */
    'adjusted': boolean;
    /**
    * Number of aggregate ( min or day ) used to generate the response
    */
    'queryCount'?: number;
    /**
    * Total number of results generated
    */
    'resultsCount'?: number;
    'results': Array<Aggv2>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "adjusted",
            "baseName": "adjusted",
            "type": "boolean"
        },
        {
            "name": "queryCount",
            "baseName": "queryCount",
            "type": "number"
        },
        {
            "name": "resultsCount",
            "baseName": "resultsCount",
            "type": "number"
        },
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<Aggv2>"
        }    ];

    static getAttributeTypeMap() {
        return AggResponse.attributeTypeMap;
    }
}

export class Aggregate {
    /**
    * Open price
    */
    'o': number;
    /**
    * Close price
    */
    'c': number;
    /**
    * Low price
    */
    'l': number;
    /**
    * High price
    */
    'h': number;
    /**
    * Total Volume of all trades ( total shares exchanged )
    */
    'v': number;
    /**
    * Transactions ( 1 transaction contains X shares exchanged )
    */
    'k': number;
    /**
    * Timestamp of this aggregation
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        },
        {
            "name": "k",
            "baseName": "k",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Aggregate.attributeTypeMap;
    }
}

export class Aggv2 {
    /**
    * Ticker symbol
    */
    'T'?: string;
    /**
    * Volume
    */
    'v': number;
    /**
    * Open
    */
    'o': number;
    /**
    * Close
    */
    'c': number;
    /**
    * High
    */
    'h': number;
    /**
    * Low
    */
    'l': number;
    /**
    * Unix Msec Timestamp ( Start of Aggregate window )
    */
    't'?: number;
    /**
    * Number of items in aggregate window
    */
    'n'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "T",
            "baseName": "T",
            "type": "string"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        },
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        },
        {
            "name": "n",
            "baseName": "n",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Aggv2.attributeTypeMap;
    }
}

export class AnalystRatings {
    /**
    * Symbol which we are requesting ratings
    */
    'symbol': string;
    /**
    * Number of analysts reporting
    */
    'analysts': number;
    /**
    * Change from last month to current
    */
    'change': number;
    /**
    * Strong buy ratings
    */
    'strongBuy': ERRORUNKNOWN;
    /**
    * Moderate buy ratings
    */
    'buy': ERRORUNKNOWN;
    /**
    * Hold ratings
    */
    'hold': ERRORUNKNOWN;
    /**
    * Moderate Sell ratings
    */
    'sell': ERRORUNKNOWN;
    /**
    * Strong Sell ratings
    */
    'strongSell': ERRORUNKNOWN;
    /**
    * Last time the ratings for this symbol were updated.
    */
    'updated': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "analysts",
            "baseName": "analysts",
            "type": "number"
        },
        {
            "name": "change",
            "baseName": "change",
            "type": "number"
        },
        {
            "name": "strongBuy",
            "baseName": "strongBuy",
            "type": "ERRORUNKNOWN"
        },
        {
            "name": "buy",
            "baseName": "buy",
            "type": "ERRORUNKNOWN"
        },
        {
            "name": "hold",
            "baseName": "hold",
            "type": "ERRORUNKNOWN"
        },
        {
            "name": "sell",
            "baseName": "sell",
            "type": "ERRORUNKNOWN"
        },
        {
            "name": "strongSell",
            "baseName": "strongSell",
            "type": "ERRORUNKNOWN"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AnalystRatings.attributeTypeMap;
    }
}

export class Company {
    /**
    * URL of the entities logo.
    */
    'logo'?: string;
    /**
    * Symbols primary exchange
    */
    'exchange': string;
    /**
    * Name of the company/entity
    */
    'name': string;
    'symbol': StockSymbol;
    /**
    * Date this symbol was listed on the exchange.
    */
    'listdate'?: string;
    /**
    * Official CIK guid used for SEC database / filings.
    */
    'cik'?: string;
    /**
    * Bloomberg guid for this symbol
    */
    'bloomberg'?: string;
    /**
    * guid for the OpenFigi project ( https://openfigi.com/ )
    */
    'figi'?: string;
    /**
    * Legal Entity Identifier (LEI) guid for symbol ( https://en.wikipedia.org/wiki/Legal_Entity_Identifier )
    */
    'lei'?: string;
    /**
    * Standard Industrial Classification (SIC) id for symbol ( https://en.wikipedia.org/wiki/Standard_Industrial_Classification )
    */
    'sic'?: number;
    /**
    * Country in which this company is registered
    */
    'country'?: string;
    /**
    * Industry this company operates in
    */
    'industry'?: string;
    /**
    * Sector of the indsutry in which this symbol operates in
    */
    'sector'?: string;
    /**
    * Current market cap for this company
    */
    'marketcap'?: number;
    /**
    * Approximate number of employees
    */
    'employees'?: number;
    /**
    * Phone number for this company. Usually corporate contact number.
    */
    'phone'?: string;
    /**
    * Name of the companies current CEO
    */
    'ceo'?: string;
    /**
    * URL of the companies website
    */
    'url'?: string;
    /**
    * A description of the company and what they do/offer
    */
    'description': string;
    'similar'?: Array<StockSymbol>;
    'tags'?: Array<string>;
    /**
    * Last time this company record was updated.
    */
    'updated': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "logo",
            "baseName": "logo",
            "type": "string"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "StockSymbol"
        },
        {
            "name": "listdate",
            "baseName": "listdate",
            "type": "string"
        },
        {
            "name": "cik",
            "baseName": "cik",
            "type": "string"
        },
        {
            "name": "bloomberg",
            "baseName": "bloomberg",
            "type": "string"
        },
        {
            "name": "figi",
            "baseName": "figi",
            "type": "string"
        },
        {
            "name": "lei",
            "baseName": "lei",
            "type": "string"
        },
        {
            "name": "sic",
            "baseName": "sic",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "industry",
            "baseName": "industry",
            "type": "string"
        },
        {
            "name": "sector",
            "baseName": "sector",
            "type": "string"
        },
        {
            "name": "marketcap",
            "baseName": "marketcap",
            "type": "number"
        },
        {
            "name": "employees",
            "baseName": "employees",
            "type": "number"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "ceo",
            "baseName": "ceo",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "similar",
            "baseName": "similar",
            "type": "Array<StockSymbol>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Company.attributeTypeMap;
    }
}

export class ConditionTypeMap {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ConditionTypeMap.attributeTypeMap;
    }
}

/**
* Parameter is invalid or incorrect.
*/
export class Conflict {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Conflict.attributeTypeMap;
    }
}

export class CryptoExchange {
    /**
    * ID of the exchange
    */
    'id': number;
    /**
    * Type of exchange feed
    */
    'type': CryptoExchange.TypeEnum;
    /**
    * Market data type this exchange contains ( crypto only currently )
    */
    'market': CryptoExchange.MarketEnum;
    /**
    * Name of the exchange
    */
    'name': string;
    /**
    * URL of this exchange
    */
    'url': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CryptoExchange.TypeEnum"
        },
        {
            "name": "market",
            "baseName": "market",
            "type": "CryptoExchange.MarketEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CryptoExchange.attributeTypeMap;
    }
}

export namespace CryptoExchange {
    export enum TypeEnum {
        Exchange = <any> 'exchange'
    }
    export enum MarketEnum {
        Crypto = <any> 'crypto'
    }
}
export class CryptoSnapshotAgg {
    /**
    * Close price
    */
    'c': number;
    /**
    * High price
    */
    'h': number;
    /**
    * Low price
    */
    'l': number;
    /**
    * Open price
    */
    'o': number;
    /**
    * Volume
    */
    'v': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CryptoSnapshotAgg.attributeTypeMap;
    }
}

export class CryptoSnapshotBookItem {
    /**
    * Price of this book level
    */
    'p': number;
    /**
    * Exchange to Size of this price level
    */
    'x': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "p",
            "baseName": "p",
            "type": "number"
        },
        {
            "name": "x",
            "baseName": "x",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CryptoSnapshotBookItem.attributeTypeMap;
    }
}

export class CryptoSnapshotTicker {
    /**
    * Ticker of the object
    */
    'ticker': string;
    'day': CryptoSnapshotAgg;
    'lastTrade': CryptoTickJson;
    'min': CryptoSnapshotAgg;
    'prevDay': CryptoSnapshotAgg;
    /**
    * Value of the change from previous day
    */
    'todaysChange': number;
    /**
    * Percentage change since previous day
    */
    'todaysChangePerc': number;
    /**
    * Last Updated timestamp
    */
    'updated': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "CryptoSnapshotAgg"
        },
        {
            "name": "lastTrade",
            "baseName": "lastTrade",
            "type": "CryptoTickJson"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "CryptoSnapshotAgg"
        },
        {
            "name": "prevDay",
            "baseName": "prevDay",
            "type": "CryptoSnapshotAgg"
        },
        {
            "name": "todaysChange",
            "baseName": "todaysChange",
            "type": "number"
        },
        {
            "name": "todaysChangePerc",
            "baseName": "todaysChangePerc",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CryptoSnapshotTicker.attributeTypeMap;
    }
}

export class CryptoSnapshotTickerBook {
    /**
    * Ticker of the object
    */
    'ticker': string;
    /**
    * Bids
    */
    'bids'?: Array<CryptoSnapshotBookItem>;
    /**
    * Asks
    */
    'asks'?: Array<CryptoSnapshotBookItem>;
    /**
    * Combined total number of bids in the book
    */
    'bidCount'?: number;
    /**
    * Combined total number of asks in the book
    */
    'askCount'?: number;
    /**
    * Difference between the best bid and the best ask price accross exchanges
    */
    'spread'?: number;
    /**
    * Last Updated timestamp
    */
    'updated': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "bids",
            "baseName": "bids",
            "type": "Array<CryptoSnapshotBookItem>"
        },
        {
            "name": "asks",
            "baseName": "asks",
            "type": "Array<CryptoSnapshotBookItem>"
        },
        {
            "name": "bidCount",
            "baseName": "bidCount",
            "type": "number"
        },
        {
            "name": "askCount",
            "baseName": "askCount",
            "type": "number"
        },
        {
            "name": "spread",
            "baseName": "spread",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CryptoSnapshotTickerBook.attributeTypeMap;
    }
}

export class CryptoTick {
    /**
    * Trade Price
    */
    'price': number;
    /**
    * Size of the trade
    */
    'size': number;
    /**
    * Exchange the trade occured on
    */
    'exchange': number;
    /**
    * Conditions of this trade
    */
    'conditions': Array<number>;
    /**
    * Timestamp of this trade
    */
    'timestamp': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "number"
        },
        {
            "name": "conditions",
            "baseName": "conditions",
            "type": "Array<number>"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CryptoTick.attributeTypeMap;
    }
}

export class CryptoTickJson {
    /**
    * Trade Price
    */
    'p': number;
    /**
    * Size of the trade
    */
    's': number;
    /**
    * Exchange the trade occured on
    */
    'x': number;
    /**
    * Conditions of this trade
    */
    'c': Array<number>;
    /**
    * Timestamp of this trade
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "p",
            "baseName": "p",
            "type": "number"
        },
        {
            "name": "s",
            "baseName": "s",
            "type": "number"
        },
        {
            "name": "x",
            "baseName": "x",
            "type": "number"
        },
        {
            "name": "c",
            "baseName": "c",
            "type": "Array<number>"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CryptoTickJson.attributeTypeMap;
    }
}

/**
* Company dividend
*/
export class Dividend {
    'symbol': StockSymbol;
    /**
    * Refers to the dividend payment type<br/> - Dividend income<br/> - Interest income<br/> - Stock dividend<br/> - Short term capital gain<br/> - Medium term capital gain<br/> - Long term capital gain<br/> - Unspecified term capital gain<br/> 
    */
    'type': string;
    /**
    * Execution date of the trade
    */
    'exDate': Date;
    /**
    * Payment date of the trade
    */
    'paymentDate'?: Date;
    /**
    * Record date of the trade
    */
    'recordDate'?: Date;
    /**
    * Declared date of the trade
    */
    'declaredDate'?: Date;
    /**
    * Amount of the dividend
    */
    'amount': number;
    /**
    * Refers to the dividend income type<br/> - P = Partially qualified income<br/> - Q = Qualified income<br/> - N = Unqualified income<br/> - null = N/A or unknown 
    */
    'qualified'?: Dividend.QualifiedEnum;
    /**
    * Refers to the dividend flag, if set<br/> FI = Final dividend, div ends or instrument ends<br/> LI = Liquidation, instrument liquidates<br/> PR = Proceeds of a sale of rights or shares<br/> RE = Redemption of rights<br/> AC = Accrued dividend<br/> AR = Payment in arrears<br/> AD = Additional payment<br/> EX = Extra payment<br/> SP = Special dividend<br/> YE = Year end<br/> UR = Unknown rate<br/> SU = Regular dividend is suspended 
    */
    'flag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "StockSymbol"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "exDate",
            "baseName": "exDate",
            "type": "Date"
        },
        {
            "name": "paymentDate",
            "baseName": "paymentDate",
            "type": "Date"
        },
        {
            "name": "recordDate",
            "baseName": "recordDate",
            "type": "Date"
        },
        {
            "name": "declaredDate",
            "baseName": "declaredDate",
            "type": "Date"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "qualified",
            "baseName": "qualified",
            "type": "Dividend.QualifiedEnum"
        },
        {
            "name": "flag",
            "baseName": "flag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dividend.attributeTypeMap;
    }
}

export namespace Dividend {
    export enum QualifiedEnum {
        P = <any> 'P',
        Q = <any> 'Q',
        N = <any> 'N',
        Null = <any> 'null'
    }
}
export class Earning {
    /**
    * Stock Symbol
    */
    'symbol': string;
    /**
    * Report Date
    */
    'ePSReportDate': Date;
    /**
    * Report date as non date format
    */
    'ePSReportDateStr': string;
    'fiscalPeriod'?: string;
    'fiscalEndDate'?: Date;
    'actualEPS'?: number;
    'consensusEPS'?: number;
    'estimatedEPS'?: number;
    'announceTime'?: string;
    'numberOfEstimates'?: number;
    'ePSSurpriseDollar'?: number;
    'yearAgo'?: number;
    'yearAgoChangePercent'?: number;
    'estimatedChangePercent'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "ePSReportDate",
            "baseName": "EPSReportDate",
            "type": "Date"
        },
        {
            "name": "ePSReportDateStr",
            "baseName": "EPSReportDateStr",
            "type": "string"
        },
        {
            "name": "fiscalPeriod",
            "baseName": "fiscalPeriod",
            "type": "string"
        },
        {
            "name": "fiscalEndDate",
            "baseName": "fiscalEndDate",
            "type": "Date"
        },
        {
            "name": "actualEPS",
            "baseName": "actualEPS",
            "type": "number"
        },
        {
            "name": "consensusEPS",
            "baseName": "consensusEPS",
            "type": "number"
        },
        {
            "name": "estimatedEPS",
            "baseName": "estimatedEPS",
            "type": "number"
        },
        {
            "name": "announceTime",
            "baseName": "announceTime",
            "type": "string"
        },
        {
            "name": "numberOfEstimates",
            "baseName": "numberOfEstimates",
            "type": "number"
        },
        {
            "name": "ePSSurpriseDollar",
            "baseName": "EPSSurpriseDollar",
            "type": "number"
        },
        {
            "name": "yearAgo",
            "baseName": "yearAgo",
            "type": "number"
        },
        {
            "name": "yearAgoChangePercent",
            "baseName": "yearAgoChangePercent",
            "type": "number"
        },
        {
            "name": "estimatedChangePercent",
            "baseName": "estimatedChangePercent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Earning.attributeTypeMap;
    }
}

export class Exchange {
    /**
    * ID of the exchange
    */
    'id': number;
    /**
    * The type of exchange this is.<br/> - TRF = Trade Reporting Facility<br/> - exchange = Reporting exchange on the tape 
    */
    'type': Exchange.TypeEnum;
    /**
    * Market data type this exchange contains
    */
    'market': Exchange.MarketEnum;
    /**
    * Market Identification Code
    */
    'mic': string;
    /**
    * Name of the exchange
    */
    'name': string;
    /**
    * Tape id of the exchange
    */
    'tape': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Exchange.TypeEnum"
        },
        {
            "name": "market",
            "baseName": "market",
            "type": "Exchange.MarketEnum"
        },
        {
            "name": "mic",
            "baseName": "mic",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tape",
            "baseName": "tape",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Exchange.attributeTypeMap;
    }
}

export namespace Exchange {
    export enum TypeEnum {
        TRF = <any> 'TRF',
        Exchange = <any> 'exchange'
    }
    export enum MarketEnum {
        Equities = <any> 'equities',
        Indecies = <any> 'indecies'
    }
}
export class Financial {
    /**
    * Stock Symbol
    */
    'symbol': string;
    /**
    * Report Date
    */
    'reportDate': Date;
    /**
    * Report date as non date format
    */
    'reportDateStr': string;
    'grossProfit'?: number;
    'costOfRevenue'?: number;
    'operatingRevenue'?: number;
    'totalRevenue'?: number;
    'operatingIncome'?: number;
    'netIncome'?: number;
    'researchAndDevelopment'?: number;
    'operatingExpense'?: number;
    'currentAssets'?: number;
    'totalAssets'?: number;
    'totalLiabilities'?: number;
    'currentCash'?: number;
    'currentDebt'?: number;
    'totalCash'?: number;
    'totalDebt'?: number;
    'shareholderEquity'?: number;
    'cashChange'?: number;
    'cashFlow'?: number;
    'operatingGainsLosses'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "reportDate",
            "baseName": "reportDate",
            "type": "Date"
        },
        {
            "name": "reportDateStr",
            "baseName": "reportDateStr",
            "type": "string"
        },
        {
            "name": "grossProfit",
            "baseName": "grossProfit",
            "type": "number"
        },
        {
            "name": "costOfRevenue",
            "baseName": "costOfRevenue",
            "type": "number"
        },
        {
            "name": "operatingRevenue",
            "baseName": "operatingRevenue",
            "type": "number"
        },
        {
            "name": "totalRevenue",
            "baseName": "totalRevenue",
            "type": "number"
        },
        {
            "name": "operatingIncome",
            "baseName": "operatingIncome",
            "type": "number"
        },
        {
            "name": "netIncome",
            "baseName": "netIncome",
            "type": "number"
        },
        {
            "name": "researchAndDevelopment",
            "baseName": "researchAndDevelopment",
            "type": "number"
        },
        {
            "name": "operatingExpense",
            "baseName": "operatingExpense",
            "type": "number"
        },
        {
            "name": "currentAssets",
            "baseName": "currentAssets",
            "type": "number"
        },
        {
            "name": "totalAssets",
            "baseName": "totalAssets",
            "type": "number"
        },
        {
            "name": "totalLiabilities",
            "baseName": "totalLiabilities",
            "type": "number"
        },
        {
            "name": "currentCash",
            "baseName": "currentCash",
            "type": "number"
        },
        {
            "name": "currentDebt",
            "baseName": "currentDebt",
            "type": "number"
        },
        {
            "name": "totalCash",
            "baseName": "totalCash",
            "type": "number"
        },
        {
            "name": "totalDebt",
            "baseName": "totalDebt",
            "type": "number"
        },
        {
            "name": "shareholderEquity",
            "baseName": "shareholderEquity",
            "type": "number"
        },
        {
            "name": "cashChange",
            "baseName": "cashChange",
            "type": "number"
        },
        {
            "name": "cashFlow",
            "baseName": "cashFlow",
            "type": "number"
        },
        {
            "name": "operatingGainsLosses",
            "baseName": "operatingGainsLosses",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Financial.attributeTypeMap;
    }
}

export class Forex {
    /**
    * Ask price
    */
    'a': number;
    /**
    * Bid price
    */
    'b': number;
    /**
    * Timestamp of this trade
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "a",
            "baseName": "a",
            "type": "number"
        },
        {
            "name": "b",
            "baseName": "b",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Forex.attributeTypeMap;
    }
}

export class ForexAggregate {
    /**
    * Open price
    */
    'o': number;
    /**
    * Close price
    */
    'c': number;
    /**
    * Low price
    */
    'l': number;
    /**
    * High price
    */
    'h': number;
    /**
    * Volume of all trades ( Number of bid/asks during this timespan )
    */
    'v': number;
    /**
    * Timestamp of this aggregation
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ForexAggregate.attributeTypeMap;
    }
}

export class ForexSnapshotAgg {
    /**
    * Close price
    */
    'c': number;
    /**
    * High price
    */
    'h': number;
    /**
    * Low price
    */
    'l': number;
    /**
    * Open price
    */
    'o': number;
    /**
    * Volume
    */
    'v': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ForexSnapshotAgg.attributeTypeMap;
    }
}

export class ForexSnapshotTicker {
    /**
    * Ticker of the object
    */
    'ticker': string;
    'day': ForexSnapshotAgg;
    'lastTrade': Forex;
    'min': ForexSnapshotAgg;
    'prevDay': ForexSnapshotAgg;
    /**
    * Value of the change from previous day
    */
    'todaysChange': number;
    /**
    * Percentage change since previous day
    */
    'todaysChangePerc': number;
    /**
    * Last Updated timestamp
    */
    'updated': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "ForexSnapshotAgg"
        },
        {
            "name": "lastTrade",
            "baseName": "lastTrade",
            "type": "Forex"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "ForexSnapshotAgg"
        },
        {
            "name": "prevDay",
            "baseName": "prevDay",
            "type": "ForexSnapshotAgg"
        },
        {
            "name": "todaysChange",
            "baseName": "todaysChange",
            "type": "number"
        },
        {
            "name": "todaysChangePerc",
            "baseName": "todaysChangePerc",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ForexSnapshotTicker.attributeTypeMap;
    }
}

export class HistTrade {
    /**
    * Condition 1 of this trade
    */
    'condition1': number;
    /**
    * Condition 2 of this trade
    */
    'condition2': number;
    /**
    * Condition 3 of this trade
    */
    'condition3': number;
    /**
    * Condition 4 of this trade
    */
    'condition4': number;
    /**
    * The exchange this trade happened on
    */
    'exchange': string;
    /**
    * Price of the trade
    */
    'price': number;
    /**
    * Size of the trade
    */
    'size': number;
    /**
    * Timestamp of this trade
    */
    'timestamp': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "condition1",
            "baseName": "condition1",
            "type": "number"
        },
        {
            "name": "condition2",
            "baseName": "condition2",
            "type": "number"
        },
        {
            "name": "condition3",
            "baseName": "condition3",
            "type": "number"
        },
        {
            "name": "condition4",
            "baseName": "condition4",
            "type": "number"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HistTrade.attributeTypeMap;
    }
}

export class InlineResponse200 {
    'symbol': Symbol;
    'endpoints': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "Symbol"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    'status'?: string;
    'results'?: Array<ERRORUNKNOWN>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<ERRORUNKNOWN>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse20010 {
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'last': LastTrade;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "LastTrade"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20010.attributeTypeMap;
    }
}

export class InlineResponse20011 {
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'last': LastQuote;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "LastQuote"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20011.attributeTypeMap;
    }
}

export class InlineResponse20012 {
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'open'?: HistTrade;
    'close'?: HistTrade;
    'afterHours'?: HistTrade;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "open",
            "baseName": "open",
            "type": "HistTrade"
        },
        {
            "name": "close",
            "baseName": "close",
            "type": "HistTrade"
        },
        {
            "name": "afterHours",
            "baseName": "afterHours",
            "type": "HistTrade"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012.attributeTypeMap;
    }
}

export class InlineResponse20013 {
    /**
    * Status of this requests response
    */
    'status': string;
    'tickers': Array<StocksSnapshotTicker>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "tickers",
            "baseName": "tickers",
            "type": "Array<StocksSnapshotTicker>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013.attributeTypeMap;
    }
}

export class InlineResponse20014 {
    /**
    * Status of this requests response
    */
    'status': string;
    'ticker'?: StocksSnapshotTicker;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "StocksSnapshotTicker"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014.attributeTypeMap;
    }
}

export class InlineResponse20015 {
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol Pair that was evaluated from the request
    */
    'symbol': string;
    'last': CryptoTick;
    'lastAverage'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "CryptoTick"
        },
        {
            "name": "lastAverage",
            "baseName": "lastAverage",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20015.attributeTypeMap;
    }
}

export class InlineResponse20016 {
    /**
    * Symbol Pair that was evaluated from the request
    */
    'symbol': string;
    /**
    * If the timestamps are in UTC timezone
    */
    'isUTC'?: boolean;
    'day'?: string;
    'openTrades'?: Array<CryptoTickJson>;
    'closingTrades'?: Array<CryptoTickJson>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "isUTC",
            "baseName": "isUTC",
            "type": "boolean"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "string"
        },
        {
            "name": "openTrades",
            "baseName": "openTrades",
            "type": "Array<CryptoTickJson>"
        },
        {
            "name": "closingTrades",
            "baseName": "closingTrades",
            "type": "Array<CryptoTickJson>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20016.attributeTypeMap;
    }
}

export class InlineResponse20017 {
    /**
    * Date that was evaluated from the request
    */
    'day': string;
    /**
    * Map for shortened result keys
    */
    'map': any;
    /**
    * Milliseconds of latency for the query results
    */
    'msLatency': number;
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'ticks': Array<CryptoTickJson>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "day",
            "baseName": "day",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        },
        {
            "name": "msLatency",
            "baseName": "msLatency",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "ticks",
            "baseName": "ticks",
            "type": "Array<CryptoTickJson>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20017.attributeTypeMap;
    }
}

export class InlineResponse20018 {
    /**
    * Status of this requests response
    */
    'status': string;
    'tickers': Array<CryptoSnapshotTicker>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "tickers",
            "baseName": "tickers",
            "type": "Array<CryptoSnapshotTicker>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20018.attributeTypeMap;
    }
}

export class InlineResponse20019 {
    /**
    * Status of this requests response
    */
    'status': string;
    'ticker'?: CryptoSnapshotTicker;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "CryptoSnapshotTicker"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20019.attributeTypeMap;
    }
}

export class InlineResponse2002 {
    'status'?: string;
    'results'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "results",
            "baseName": "results",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002.attributeTypeMap;
    }
}

export class InlineResponse20020 {
    /**
    * Status of this requests response
    */
    'status': string;
    'data'?: CryptoSnapshotTickerBook;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "CryptoSnapshotTickerBook"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20020.attributeTypeMap;
    }
}

export class InlineResponse2003 {
    'status'?: string;
    'count'?: number;
    'results'?: Array<Split>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "results",
            "baseName": "results",
            "type": "Array<Split>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003.attributeTypeMap;
    }
}

export class InlineResponse2004 {
    /**
    * Date that was evaluated from the request
    */
    'day': string;
    /**
    * Map for shortened result keys
    */
    'map': any;
    /**
    * Milliseconds of latency for the query results
    */
    'msLatency': number;
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Currency Pair that was evaluated from the request
    */
    'pair': string;
    'ticks': Array<Forex>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "day",
            "baseName": "day",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        },
        {
            "name": "msLatency",
            "baseName": "msLatency",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "pair",
            "baseName": "pair",
            "type": "string"
        },
        {
            "name": "ticks",
            "baseName": "ticks",
            "type": "Array<Forex>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004.attributeTypeMap;
    }
}

export class InlineResponse2005 {
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * From currency symbol
    */
    'from': string;
    /**
    * To currency symbol
    */
    'to': string;
    /**
    * The amount we are to convert
    */
    'initialAmount': number;
    /**
    * To currency symbol
    */
    'converted': number;
    'lastTrade': LastForexTrade;
    /**
    * Symbol Pair that was evaluated from the request
    */
    'symbol'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "initialAmount",
            "baseName": "initialAmount",
            "type": "number"
        },
        {
            "name": "converted",
            "baseName": "converted",
            "type": "number"
        },
        {
            "name": "lastTrade",
            "baseName": "lastTrade",
            "type": "LastForexTrade"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005.attributeTypeMap;
    }
}

export class InlineResponse2006 {
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol Pair that was evaluated from the request
    */
    'symbol': string;
    'last': LastForexQuote;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "LastForexQuote"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006.attributeTypeMap;
    }
}

export class InlineResponse2007 {
    /**
    * Status of this requests response
    */
    'status': string;
    'tickers': Array<ForexSnapshotTicker>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "tickers",
            "baseName": "tickers",
            "type": "Array<ForexSnapshotTicker>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2007.attributeTypeMap;
    }
}

export class InlineResponse2008 {
    /**
    * Date that was evaluated from the request
    */
    'day': string;
    /**
    * Map for shortened result keys
    */
    'map': any;
    /**
    * Milliseconds of latency for the query results
    */
    'msLatency': number;
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'ticks': Array<Trade>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "day",
            "baseName": "day",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        },
        {
            "name": "msLatency",
            "baseName": "msLatency",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "ticks",
            "baseName": "ticks",
            "type": "Array<Trade>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008.attributeTypeMap;
    }
}

export class InlineResponse2009 {
    /**
    * Date that was evaluated from the request
    */
    'day': string;
    /**
    * Map for shortened result keys
    */
    'map': any;
    /**
    * Milliseconds of latency for the query results
    */
    'msLatency': number;
    /**
    * Status of this requests response
    */
    'status': string;
    /**
    * Symbol that was evaluated from the request
    */
    'symbol': string;
    'ticks': Array<Quote>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "day",
            "baseName": "day",
            "type": "string"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "any"
        },
        {
            "name": "msLatency",
            "baseName": "msLatency",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "ticks",
            "baseName": "ticks",
            "type": "Array<Quote>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2009.attributeTypeMap;
    }
}

export class LastForexQuote {
    /**
    * Ask Price
    */
    'ask': number;
    /**
    * Bid Price
    */
    'bid': number;
    /**
    * Exchange this trade happened on
    */
    'exchange': number;
    /**
    * Timestamp of this trade
    */
    'timestamp': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ask",
            "baseName": "ask",
            "type": "number"
        },
        {
            "name": "bid",
            "baseName": "bid",
            "type": "number"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LastForexQuote.attributeTypeMap;
    }
}

export class LastForexTrade {
    /**
    * Price of the trade
    */
    'price': number;
    /**
    * Exchange this trade happened on
    */
    'exchange': number;
    /**
    * Timestamp of this trade
    */
    'timestamp': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LastForexTrade.attributeTypeMap;
    }
}

export class LastQuote {
    /**
    * Ask Price
    */
    'askprice': number;
    /**
    * Ask Size
    */
    'asksize': number;
    /**
    * Exchange the ask happened on
    */
    'askexchange': number;
    /**
    * Bid Price
    */
    'bidprice': number;
    /**
    * Bid Size
    */
    'bidsize': number;
    /**
    * Exchange the bid happened on
    */
    'bidexchange': number;
    /**
    * Timestamp of this trade
    */
    'timestamp': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "askprice",
            "baseName": "askprice",
            "type": "number"
        },
        {
            "name": "asksize",
            "baseName": "asksize",
            "type": "number"
        },
        {
            "name": "askexchange",
            "baseName": "askexchange",
            "type": "number"
        },
        {
            "name": "bidprice",
            "baseName": "bidprice",
            "type": "number"
        },
        {
            "name": "bidsize",
            "baseName": "bidsize",
            "type": "number"
        },
        {
            "name": "bidexchange",
            "baseName": "bidexchange",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LastQuote.attributeTypeMap;
    }
}

export class LastTrade {
    /**
    * Price of the trade
    */
    'price': number;
    /**
    * Size of this trade
    */
    'size': number;
    /**
    * Exchange this trade happened on
    */
    'exchange': number;
    /**
    * Condition 1 of the trade
    */
    'cond1': number;
    /**
    * Condition 2 of the trade
    */
    'cond2': number;
    /**
    * Condition 3 of the trade
    */
    'cond3': number;
    /**
    * Condition 4 of the trade
    */
    'cond4': number;
    /**
    * Timestamp of this trade
    */
    'timestamp': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "number"
        },
        {
            "name": "cond1",
            "baseName": "cond1",
            "type": "number"
        },
        {
            "name": "cond2",
            "baseName": "cond2",
            "type": "number"
        },
        {
            "name": "cond3",
            "baseName": "cond3",
            "type": "number"
        },
        {
            "name": "cond4",
            "baseName": "cond4",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LastTrade.attributeTypeMap;
    }
}

export class MarketHoliday {
    /**
    * Which market this record is for
    */
    'exchange': MarketHoliday.ExchangeEnum;
    /**
    * Human readable description of the holiday
    */
    'name': string;
    /**
    * Status of the market on this holiday
    */
    'status': MarketHoliday.StatusEnum;
    /**
    * Date of this holiday
    */
    'date': Date;
    /**
    * Market open time on this holiday ( if it's not closed )
    */
    'open'?: Date;
    /**
    * Market close time on this holiday ( if it's not closed )
    */
    'close'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exchange",
            "baseName": "exchange",
            "type": "MarketHoliday.ExchangeEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "MarketHoliday.StatusEnum"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "open",
            "baseName": "open",
            "type": "Date"
        },
        {
            "name": "close",
            "baseName": "close",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return MarketHoliday.attributeTypeMap;
    }
}

export namespace MarketHoliday {
    export enum ExchangeEnum {
        NYSE = <any> 'NYSE',
        NASDAQ = <any> 'NASDAQ',
        OTC = <any> 'OTC'
    }
    export enum StatusEnum {
        Closed = <any> 'closed',
        EarlyClose = <any> 'early-close',
        LateClose = <any> 'late-close',
        EarlyOpen = <any> 'early-open',
        LateOpen = <any> 'late-open'
    }
}
export class MarketStatus {
    /**
    * Status of the market as a whole
    */
    'market': MarketStatus.MarketEnum;
    /**
    * Current time of the server
    */
    'serverTime': Date;
    'exchanges': MarketStatusExchanges;
    'currencies'?: MarketStatusCurrencies;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "market",
            "baseName": "market",
            "type": "MarketStatus.MarketEnum"
        },
        {
            "name": "serverTime",
            "baseName": "serverTime",
            "type": "Date"
        },
        {
            "name": "exchanges",
            "baseName": "exchanges",
            "type": "MarketStatusExchanges"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "MarketStatusCurrencies"
        }    ];

    static getAttributeTypeMap() {
        return MarketStatus.attributeTypeMap;
    }
}

export namespace MarketStatus {
    export enum MarketEnum {
        Open = <any> 'open',
        Closed = <any> 'closed',
        ExtendedHours = <any> 'extended-hours'
    }
}
export class MarketStatusCurrencies {
    /**
    * Status of the forex market
    */
    'fx'?: MarketStatusCurrencies.FxEnum;
    /**
    * Status of the crypto market
    */
    'crypto'?: MarketStatusCurrencies.CryptoEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fx",
            "baseName": "fx",
            "type": "MarketStatusCurrencies.FxEnum"
        },
        {
            "name": "crypto",
            "baseName": "crypto",
            "type": "MarketStatusCurrencies.CryptoEnum"
        }    ];

    static getAttributeTypeMap() {
        return MarketStatusCurrencies.attributeTypeMap;
    }
}

export namespace MarketStatusCurrencies {
    export enum FxEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
    export enum CryptoEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
}
export class MarketStatusExchanges {
    /**
    * Status of the market as a whole
    */
    'nyse'?: MarketStatusExchanges.NyseEnum;
    /**
    * Status of the market as a whole
    */
    'nasdaq'?: MarketStatusExchanges.NasdaqEnum;
    /**
    * Status of the market as a whole
    */
    'otc'?: MarketStatusExchanges.OtcEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nyse",
            "baseName": "nyse",
            "type": "MarketStatusExchanges.NyseEnum"
        },
        {
            "name": "nasdaq",
            "baseName": "nasdaq",
            "type": "MarketStatusExchanges.NasdaqEnum"
        },
        {
            "name": "otc",
            "baseName": "otc",
            "type": "MarketStatusExchanges.OtcEnum"
        }    ];

    static getAttributeTypeMap() {
        return MarketStatusExchanges.attributeTypeMap;
    }
}

export namespace MarketStatusExchanges {
    export enum NyseEnum {
        Open = <any> 'open',
        Closed = <any> 'closed',
        ExtendedHours = <any> 'extended-hours'
    }
    export enum NasdaqEnum {
        Open = <any> 'open',
        Closed = <any> 'closed',
        ExtendedHours = <any> 'extended-hours'
    }
    export enum OtcEnum {
        Open = <any> 'open',
        Closed = <any> 'closed',
        ExtendedHours = <any> 'extended-hours'
    }
}
export class ModelError {
    'code'?: number;
    'message'?: string;
    'fields'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

export class News {
    'symbols': Array<StockSymbol>;
    /**
    * Name of the article
    */
    'title': string;
    /**
    * URL of this article
    */
    'url': string;
    /**
    * Source of this article
    */
    'source': string;
    /**
    * Short summary of the article
    */
    'summary': string;
    /**
    * URL of the image for this article, if found
    */
    'image'?: string;
    /**
    * Timestamp of the article
    */
    'timestamp': Date;
    'keywords'?: Array<ERRORUNKNOWN>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbols",
            "baseName": "symbols",
            "type": "Array<StockSymbol>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "Array<ERRORUNKNOWN>"
        }    ];

    static getAttributeTypeMap() {
        return News.attributeTypeMap;
    }
}

/**
* The specified resource was not found
*/
export class NotFound {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotFound.attributeTypeMap;
    }
}

export class Quote {
    /**
    * Condition of this quote
    */
    'c': number;
    /**
    * Bid Exchange
    */
    'bE': string;
    /**
    * Ask Exchange
    */
    'aE': string;
    /**
    * Ask Price
    */
    'aP': number;
    /**
    * Bid Price
    */
    'bP': number;
    /**
    * Bid Size
    */
    'bS': number;
    /**
    * Ask Size
    */
    'aS': number;
    /**
    * Timestamp of this trade
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "bE",
            "baseName": "bE",
            "type": "string"
        },
        {
            "name": "aE",
            "baseName": "aE",
            "type": "string"
        },
        {
            "name": "aP",
            "baseName": "aP",
            "type": "number"
        },
        {
            "name": "bP",
            "baseName": "bP",
            "type": "number"
        },
        {
            "name": "bS",
            "baseName": "bS",
            "type": "number"
        },
        {
            "name": "aS",
            "baseName": "aS",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Quote.attributeTypeMap;
    }
}

export class RatingSection {
    /**
    * Analyst Rating at current month
    */
    'current': number;
    /**
    * Analyst Ratings at 1 month in the future
    */
    'month1': number;
    /**
    * Analyst Ratings at 2 month in the future
    */
    'month2': number;
    /**
    * Analyst Ratings at 3 month in the future
    */
    'month3': number;
    /**
    * Analyst Ratings at 4 month in the future
    */
    'month4'?: number;
    /**
    * Analyst Ratings at 5 month in the future
    */
    'month5'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "current",
            "baseName": "current",
            "type": "number"
        },
        {
            "name": "month1",
            "baseName": "month1",
            "type": "number"
        },
        {
            "name": "month2",
            "baseName": "month2",
            "type": "number"
        },
        {
            "name": "month3",
            "baseName": "month3",
            "type": "number"
        },
        {
            "name": "month4",
            "baseName": "month4",
            "type": "number"
        },
        {
            "name": "month5",
            "baseName": "month5",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RatingSection.attributeTypeMap;
    }
}

/**
* Symbol split
*/
export class Split {
    'ticker': TickerSymbol;
    /**
    * Execution date of the split
    */
    'exDate': Date;
    /**
    * Payment date of the split
    */
    'paymentDate': Date;
    /**
    * Payment date of the split
    */
    'recordDate'?: Date;
    /**
    * Payment date of the split
    */
    'declaredDate'?: Date;
    /**
    * refers to the split ratio. The split ratio is an inverse of the number of shares that a holder of the stock would have after the split divided by the number of shares that the holder had before. <br/> For example: Split ratio of .5 = 2 for 1 split. 
    */
    'ratio': number;
    /**
    * To factor of the split. Used to calculate the split ratio forfactor/tofactor = ratio (eg ½ = 0.5) 
    */
    'tofactor': number;
    /**
    * For factor of the split. Used to calculate the split ratio forfactor/tofactor = ratio (eg ½ = 0.5) 
    */
    'forfactor': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "TickerSymbol"
        },
        {
            "name": "exDate",
            "baseName": "exDate",
            "type": "Date"
        },
        {
            "name": "paymentDate",
            "baseName": "paymentDate",
            "type": "Date"
        },
        {
            "name": "recordDate",
            "baseName": "recordDate",
            "type": "Date"
        },
        {
            "name": "declaredDate",
            "baseName": "declaredDate",
            "type": "Date"
        },
        {
            "name": "ratio",
            "baseName": "ratio",
            "type": "number"
        },
        {
            "name": "tofactor",
            "baseName": "tofactor",
            "type": "number"
        },
        {
            "name": "forfactor",
            "baseName": "forfactor",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Split.attributeTypeMap;
    }
}

/**
* An actual exchange symbol this item is traded under.
*/
export class StockSymbol {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return StockSymbol.attributeTypeMap;
    }
}

export class StocksSnapshotAgg {
    /**
    * Close price
    */
    'c': number;
    /**
    * High price
    */
    'h': number;
    /**
    * Low price
    */
    'l': number;
    /**
    * Open price
    */
    'o': number;
    /**
    * Volume
    */
    'v': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "h",
            "baseName": "h",
            "type": "number"
        },
        {
            "name": "l",
            "baseName": "l",
            "type": "number"
        },
        {
            "name": "o",
            "baseName": "o",
            "type": "number"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StocksSnapshotAgg.attributeTypeMap;
    }
}

export class StocksSnapshotBookItem {
    /**
    * Price of this book level
    */
    'p': number;
    /**
    * Exchange to Size of this price level
    */
    'x': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "p",
            "baseName": "p",
            "type": "number"
        },
        {
            "name": "x",
            "baseName": "x",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return StocksSnapshotBookItem.attributeTypeMap;
    }
}

export class StocksSnapshotTicker {
    /**
    * Ticker of the object
    */
    'ticker': string;
    'day': StocksSnapshotAgg;
    'lastTrade': Trade;
    'min': StocksSnapshotAgg;
    'prevDay': StocksSnapshotAgg;
    /**
    * Value of the change from previous day
    */
    'todaysChange': number;
    /**
    * Percentage change since previous day
    */
    'todaysChangePerc': number;
    /**
    * Last Updated timestamp
    */
    'updated': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "StocksSnapshotAgg"
        },
        {
            "name": "lastTrade",
            "baseName": "lastTrade",
            "type": "Trade"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "StocksSnapshotAgg"
        },
        {
            "name": "prevDay",
            "baseName": "prevDay",
            "type": "StocksSnapshotAgg"
        },
        {
            "name": "todaysChange",
            "baseName": "todaysChange",
            "type": "number"
        },
        {
            "name": "todaysChangePerc",
            "baseName": "todaysChangePerc",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StocksSnapshotTicker.attributeTypeMap;
    }
}

export class StocksSnapshotTickerBook {
    /**
    * Ticker of the object
    */
    'ticker': string;
    /**
    * Bids
    */
    'bids'?: Array<StocksSnapshotBookItem>;
    /**
    * Asks
    */
    'asks'?: Array<StocksSnapshotBookItem>;
    /**
    * Combined total number of bids in the book
    */
    'bidCount'?: number;
    /**
    * Combined total number of asks in the book
    */
    'askCount'?: number;
    /**
    * Difference between the best bid and the best ask price accross exchanges
    */
    'spread'?: number;
    /**
    * Last Updated timestamp
    */
    'updated': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "string"
        },
        {
            "name": "bids",
            "baseName": "bids",
            "type": "Array<StocksSnapshotBookItem>"
        },
        {
            "name": "asks",
            "baseName": "asks",
            "type": "Array<StocksSnapshotBookItem>"
        },
        {
            "name": "bidCount",
            "baseName": "bidCount",
            "type": "number"
        },
        {
            "name": "askCount",
            "baseName": "askCount",
            "type": "number"
        },
        {
            "name": "spread",
            "baseName": "spread",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StocksSnapshotTickerBook.attributeTypeMap;
    }
}

export class Symbol {
    'symbol': StockSymbol;
    /**
    * Name of the item.
    */
    'name': string;
    /**
    * Type of symbol this is. See symbol types.
    */
    'type': string;
    /**
    * URL of this symbol. Use this to get this symbols endpoints.
    */
    'url': string;
    /**
    * Last time this company record was updated.
    */
    'updated': Date;
    /**
    * If the symbol is listed on the OTC Markets.
    */
    'isOTC': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "StockSymbol"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "isOTC",
            "baseName": "isOTC",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Symbol.attributeTypeMap;
    }
}

export class SymbolTypeMap {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SymbolTypeMap.attributeTypeMap;
    }
}

export class Ticker {
    'ticker': StockSymbol;
    /**
    * Name of the item.
    */
    'name': string;
    /**
    * The market in which this ticker participates
    */
    'market': string;
    /**
    * Locale of where this ticker is traded
    */
    'locale': string;
    /**
    * Currency this ticker is traded in
    */
    'currency'?: string;
    /**
    * If the ticker is active. False means the ticker has been delisted
    */
    'active'?: boolean;
    /**
    * The listing exchange for this ticker
    */
    'primaryExch'?: string;
    /**
    * URL of this ticker. Use this to get more information about the ticker.
    */
    'url'?: string;
    /**
    * Last time this ticker record was updated.
    */
    'updated': Date;
    /**
    * Additional details about this ticker. No schema.
    */
    'attrs'?: any;
    'codes'?: TickerCodes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticker",
            "baseName": "ticker",
            "type": "StockSymbol"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "market",
            "baseName": "market",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "primaryExch",
            "baseName": "primaryExch",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        },
        {
            "name": "attrs",
            "baseName": "attrs",
            "type": "any"
        },
        {
            "name": "codes",
            "baseName": "codes",
            "type": "TickerCodes"
        }    ];

    static getAttributeTypeMap() {
        return Ticker.attributeTypeMap;
    }
}

/**
* Additional details about this ticker. No schema.
*/
export class TickerCodes {
    /**
    * CIK number for this ticker
    */
    'cik'?: string;
    /**
    * OpenFIGI number for this ticker
    */
    'figi'?: string;
    /**
    * Composite OpenFIGI number for this ticker
    */
    'cfigi'?: string;
    /**
    * Shared Class OpenFIGI number for this ticker
    */
    'scfigi'?: string;
    /**
    * Unique OpenFIGI ID number for this ticker
    */
    'figiuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cik",
            "baseName": "cik",
            "type": "string"
        },
        {
            "name": "figi",
            "baseName": "figi",
            "type": "string"
        },
        {
            "name": "cfigi",
            "baseName": "cfigi",
            "type": "string"
        },
        {
            "name": "scfigi",
            "baseName": "scfigi",
            "type": "string"
        },
        {
            "name": "figiuid",
            "baseName": "figiuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TickerCodes.attributeTypeMap;
    }
}

/**
* An actual exchange traded ticker.
*/
export class TickerSymbol {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TickerSymbol.attributeTypeMap;
    }
}

export class Trade {
    /**
    * Condition 1 of this trade
    */
    'c1': number;
    /**
    * Condition 2 of this trade
    */
    'c2': number;
    /**
    * Condition 3 of this trade
    */
    'c3': number;
    /**
    * Condition 4 of this trade
    */
    'c4': number;
    /**
    * The exchange this trade happened on
    */
    'e': string;
    /**
    * Price of the trade
    */
    'p': number;
    /**
    * Size of the trade
    */
    's': number;
    /**
    * Timestamp of this trade
    */
    't': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "c1",
            "baseName": "c1",
            "type": "number"
        },
        {
            "name": "c2",
            "baseName": "c2",
            "type": "number"
        },
        {
            "name": "c3",
            "baseName": "c3",
            "type": "number"
        },
        {
            "name": "c4",
            "baseName": "c4",
            "type": "number"
        },
        {
            "name": "e",
            "baseName": "e",
            "type": "string"
        },
        {
            "name": "p",
            "baseName": "p",
            "type": "number"
        },
        {
            "name": "s",
            "baseName": "s",
            "type": "number"
        },
        {
            "name": "t",
            "baseName": "t",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Trade.attributeTypeMap;
    }
}

/**
* Unauthorized - Check our API Key and account status
*/
export class Unauthorized {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Unauthorized.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "CryptoExchange.TypeEnum": CryptoExchange.TypeEnum,
        "CryptoExchange.MarketEnum": CryptoExchange.MarketEnum,
        "Dividend.QualifiedEnum": Dividend.QualifiedEnum,
        "Exchange.TypeEnum": Exchange.TypeEnum,
        "Exchange.MarketEnum": Exchange.MarketEnum,
        "MarketHoliday.ExchangeEnum": MarketHoliday.ExchangeEnum,
        "MarketHoliday.StatusEnum": MarketHoliday.StatusEnum,
        "MarketStatus.MarketEnum": MarketStatus.MarketEnum,
        "MarketStatusCurrencies.FxEnum": MarketStatusCurrencies.FxEnum,
        "MarketStatusCurrencies.CryptoEnum": MarketStatusCurrencies.CryptoEnum,
        "MarketStatusExchanges.NyseEnum": MarketStatusExchanges.NyseEnum,
        "MarketStatusExchanges.NasdaqEnum": MarketStatusExchanges.NasdaqEnum,
        "MarketStatusExchanges.OtcEnum": MarketStatusExchanges.OtcEnum,
}

let typeMap: {[index: string]: any} = {
    "AggResponse": AggResponse,
    "Aggregate": Aggregate,
    "Aggv2": Aggv2,
    "AnalystRatings": AnalystRatings,
    "Company": Company,
    "ConditionTypeMap": ConditionTypeMap,
    "Conflict": Conflict,
    "CryptoExchange": CryptoExchange,
    "CryptoSnapshotAgg": CryptoSnapshotAgg,
    "CryptoSnapshotBookItem": CryptoSnapshotBookItem,
    "CryptoSnapshotTicker": CryptoSnapshotTicker,
    "CryptoSnapshotTickerBook": CryptoSnapshotTickerBook,
    "CryptoTick": CryptoTick,
    "CryptoTickJson": CryptoTickJson,
    "Dividend": Dividend,
    "Earning": Earning,
    "Exchange": Exchange,
    "Financial": Financial,
    "Forex": Forex,
    "ForexAggregate": ForexAggregate,
    "ForexSnapshotAgg": ForexSnapshotAgg,
    "ForexSnapshotTicker": ForexSnapshotTicker,
    "HistTrade": HistTrade,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse20010": InlineResponse20010,
    "InlineResponse20011": InlineResponse20011,
    "InlineResponse20012": InlineResponse20012,
    "InlineResponse20013": InlineResponse20013,
    "InlineResponse20014": InlineResponse20014,
    "InlineResponse20015": InlineResponse20015,
    "InlineResponse20016": InlineResponse20016,
    "InlineResponse20017": InlineResponse20017,
    "InlineResponse20018": InlineResponse20018,
    "InlineResponse20019": InlineResponse20019,
    "InlineResponse2002": InlineResponse2002,
    "InlineResponse20020": InlineResponse20020,
    "InlineResponse2003": InlineResponse2003,
    "InlineResponse2004": InlineResponse2004,
    "InlineResponse2005": InlineResponse2005,
    "InlineResponse2006": InlineResponse2006,
    "InlineResponse2007": InlineResponse2007,
    "InlineResponse2008": InlineResponse2008,
    "InlineResponse2009": InlineResponse2009,
    "LastForexQuote": LastForexQuote,
    "LastForexTrade": LastForexTrade,
    "LastQuote": LastQuote,
    "LastTrade": LastTrade,
    "MarketHoliday": MarketHoliday,
    "MarketStatus": MarketStatus,
    "MarketStatusCurrencies": MarketStatusCurrencies,
    "MarketStatusExchanges": MarketStatusExchanges,
    "ModelError": ModelError,
    "News": News,
    "NotFound": NotFound,
    "Quote": Quote,
    "RatingSection": RatingSection,
    "Split": Split,
    "StockSymbol": StockSymbol,
    "StocksSnapshotAgg": StocksSnapshotAgg,
    "StocksSnapshotBookItem": StocksSnapshotBookItem,
    "StocksSnapshotTicker": StocksSnapshotTicker,
    "StocksSnapshotTickerBook": StocksSnapshotTickerBook,
    "Symbol": Symbol,
    "SymbolTypeMap": SymbolTypeMap,
    "Ticker": Ticker,
    "TickerCodes": TickerCodes,
    "TickerSymbol": TickerSymbol,
    "Trade": Trade,
    "Unauthorized": Unauthorized,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CryptoApiApiKeys {
    apiKey,
}

export class CryptoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CryptoApiApiKeys, value: string) {
        (this.authentications as any)[CryptoApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get historic trade ticks for a crypto pair. 
     * @summary Historic Crypto Trades
     * @param from From Symbol of the crypto pair
     * @param to To Symbol of the crypto pair
     * @param date Date/Day of the historic ticks to retreive
     * @param offset Timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param limit Limit the size of response, Max 10000
     * @param {*} [options] Override http request options.
     */
    public v1HistoricCryptoFromToDateGet (from: string, to: string, date: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20017;  }> {
        const localVarPath = this.basePath + '/v1/historic/crypto/{from}/{to}/{date}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1HistoricCryptoFromToDateGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1HistoricCryptoFromToDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1HistoricCryptoFromToDateGet.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20017;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20017");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Last Trade Tick for a Currency Pair. 
     * @summary Last Trade for a Crypto Pair
     * @param from From Symbol of the pair
     * @param to To Symbol of the pair
     * @param {*} [options] Override http request options.
     */
    public v1LastCryptoFromToGet (from: string, to: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20015;  }> {
        const localVarPath = this.basePath + '/v1/last/crypto/{from}/{to}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1LastCryptoFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1LastCryptoFromToGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20015;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20015");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of crypto currency exchanges which are supported by Polygon.io 
     * @summary Crypto Exchanges
     * @param {*} [options] Override http request options.
     */
    public v1MetaCryptoExchangesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<CryptoExchange>;  }> {
        const localVarPath = this.basePath + '/v1/meta/crypto-exchanges';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CryptoExchange>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CryptoExchange>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the open, close prices of a symbol on a certain day. 
     * @summary Daily Open / Close
     * @param from From Symbol of the pair
     * @param to To Symbol of the pair
     * @param date Date of the requested open/close
     * @param {*} [options] Override http request options.
     */
    public v1OpenCloseCryptoFromToDateGet (from: string, to: string, date: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20016;  }> {
        const localVarPath = this.basePath + '/v1/open-close/crypto/{from}/{to}/{date}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1OpenCloseCryptoFromToDateGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1OpenCloseCryptoFromToDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1OpenCloseCryptoFromToDateGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20016;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20016");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the daily OHLC for entire markets.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Grouped Daily
     * @param locale Locale of the aggregates ( See &#39;Locales&#39; API )
     * @param market Market of the aggregates ( See &#39;Markets&#39; API )
     * @param date To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsGroupedLocaleLocaleMarketMarketDateGet (locale: 'GLOBAL' | 'US' | 'GB' | 'CA' | 'NL' | 'GR' | 'SP' | 'DE' | 'BE' | 'DK' | 'FI' | 'IE' | 'PT' | 'IN' | 'MX' | 'FR' | 'CN' | 'CH' | 'SE', market: 'STOCKS' | 'CRYPTO' | 'BONDS' | 'MF' | 'MMF' | 'INDICES' | 'FX', date: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/grouped/locale/{locale}/market/{market}/{date}'
            .replace('{' + 'locale' + '}', encodeURIComponent(String(locale)))
            .replace('{' + 'market' + '}', encodeURIComponent(String(market)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locale' is not null or undefined
        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'market' is not null or undefined
        if (market === null || market === undefined) {
            throw new Error('Required parameter market was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the previous day close for the specified ticker 
     * @summary Previous Close
     * @param ticker Ticker symbol of the request
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerPrevGet (ticker: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/prev'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerPrevGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get aggregates for a date range, in custom time window sizes 
     * @summary Aggregates
     * @param ticker Ticker symbol of the request
     * @param multiplier Size of the timespan multiplier
     * @param timespan Size of the time window
     * @param from From date
     * @param to To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerRangeMultiplierTimespanFromToGet (ticker: string, multiplier: number, timespan: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', from: string, to: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/range/{multiplier}/{timespan}/{from}/{to}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)))
            .replace('{' + 'multiplier' + '}', encodeURIComponent(String(multiplier)))
            .replace('{' + 'timespan' + '}', encodeURIComponent(String(timespan)))
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'multiplier' is not null or undefined
        if (multiplier === null || multiplier === undefined) {
            throw new Error('Required parameter multiplier was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'timespan' is not null or undefined
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 gainers of the day at the moment. 
     * @summary Snapshot - Gainers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsCryptoGainersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/crypto/gainers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20018");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 losers of the day at the moment. 
     * @summary Snapshot - Losers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsCryptoLosersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/crypto/losers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20018");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Snapshot allows you to see all tickers current minute aggregate, daily aggregate and last trade. As well as previous days aggregate and calculated change for today.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Snapshot - All Tickers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/crypto/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20018;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20018");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current level 2 book of a single ticker. This is the combined book from all the exchanges. 
     * @summary Snapshot - Single Ticker Full Book ( L2 )
     * @param ticker Ticker of the snapshot
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet (ticker: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20020;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2SnapshotLocaleGlobalMarketsCryptoTickersTickerBookGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20020;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20020");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of a single ticker 
     * @summary Snapshot - Single Ticker
     * @param ticker Ticker of the snapshot
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet (ticker: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20019;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2SnapshotLocaleGlobalMarketsCryptoTickersTickerGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20019;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20019");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ForexCurrenciesApiApiKeys {
    apiKey,
}

export class ForexCurrenciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ForexCurrenciesApiApiKeys, value: string) {
        (this.authentications as any)[ForexCurrenciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Convert currencies using the latest market conversion rates. Note than you can convert in both directions. For example USD->CAD or CAD->USD. 
     * @summary Real-time Currency Conversion
     * @param from From Symbol of the pair
     * @param to To Symbol of the pair
     * @param amount Amount we want to convert. With decimal
     * @param precision Decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy.
     * @param {*} [options] Override http request options.
     */
    public v1ConversionFromToGet (from: string, to: string, amount?: number, precision?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }> {
        const localVarPath = this.basePath + '/v1/conversion/{from}/{to}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1ConversionFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1ConversionFromToGet.');
        }

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (precision !== undefined) {
            localVarQueryParameters['precision'] = ObjectSerializer.serialize(precision, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2005");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get historic ticks for a currency pair. Example for **USD/JPY** the from would be **USD** and to would be **JPY**. The date formatted like **2017-6-22** 
     * @summary Historic Forex Ticks
     * @param from From Symbol of the currency pair
     * @param to To Symbol of the currency pair
     * @param date Date/Day of the historic ticks to retreive
     * @param offset Timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param limit Limit the size of response, Max 10000
     * @param {*} [options] Override http request options.
     */
    public v1HistoricForexFromToDateGet (from: string, to: string, date: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/v1/historic/forex/{from}/{to}/{date}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1HistoricForexFromToDateGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1HistoricForexFromToDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1HistoricForexFromToDateGet.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2004");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Last Quote Tick for a Currency Pair. 
     * @summary Last Quote for a Currency Pair
     * @param from From Symbol of the pair
     * @param to To Symbol of the pair
     * @param {*} [options] Override http request options.
     */
    public v1LastQuoteCurrenciesFromToGet (from: string, to: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/v1/last_quote/currencies/{from}/{to}'
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v1LastQuoteCurrenciesFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v1LastQuoteCurrenciesFromToGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2006");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the daily OHLC for entire markets.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Grouped Daily
     * @param locale Locale of the aggregates ( See &#39;Locales&#39; API )
     * @param market Market of the aggregates ( See &#39;Markets&#39; API )
     * @param date To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsGroupedLocaleLocaleMarketMarketDateGet (locale: 'GLOBAL' | 'US' | 'GB' | 'CA' | 'NL' | 'GR' | 'SP' | 'DE' | 'BE' | 'DK' | 'FI' | 'IE' | 'PT' | 'IN' | 'MX' | 'FR' | 'CN' | 'CH' | 'SE', market: 'STOCKS' | 'CRYPTO' | 'BONDS' | 'MF' | 'MMF' | 'INDICES' | 'FX', date: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/grouped/locale/{locale}/market/{market}/{date}'
            .replace('{' + 'locale' + '}', encodeURIComponent(String(locale)))
            .replace('{' + 'market' + '}', encodeURIComponent(String(market)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locale' is not null or undefined
        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'market' is not null or undefined
        if (market === null || market === undefined) {
            throw new Error('Required parameter market was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the previous day close for the specified ticker 
     * @summary Previous Close
     * @param ticker Ticker symbol of the request
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerPrevGet (ticker: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/prev'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerPrevGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get aggregates for a date range, in custom time window sizes 
     * @summary Aggregates
     * @param ticker Ticker symbol of the request
     * @param multiplier Size of the timespan multiplier
     * @param timespan Size of the time window
     * @param from From date
     * @param to To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerRangeMultiplierTimespanFromToGet (ticker: string, multiplier: number, timespan: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', from: string, to: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/range/{multiplier}/{timespan}/{from}/{to}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)))
            .replace('{' + 'multiplier' + '}', encodeURIComponent(String(multiplier)))
            .replace('{' + 'timespan' + '}', encodeURIComponent(String(timespan)))
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'multiplier' is not null or undefined
        if (multiplier === null || multiplier === undefined) {
            throw new Error('Required parameter multiplier was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'timespan' is not null or undefined
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 gainers of the day at the moment. 
     * @summary Snapshot - Gainers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsForexGainersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/forex/gainers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2007");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 losers of the day at the moment. 
     * @summary Snapshot - Losers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsForexLosersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/forex/losers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2007");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Snapshot allows you to see all tickers current minute aggregate, daily aggregate and last trade. As well as previous days aggregate and calculated change for today.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Snapshot - All Tickers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleGlobalMarketsForexTickersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/global/markets/forex/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2007");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IndicesApiApiKeys {
    apiKey,
}

export class IndicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IndicesApiApiKeys, value: string) {
        (this.authentications as any)[IndicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the daily OHLC for entire markets.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Grouped Daily
     * @param locale Locale of the aggregates ( See &#39;Locales&#39; API )
     * @param market Market of the aggregates ( See &#39;Markets&#39; API )
     * @param date To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsGroupedLocaleLocaleMarketMarketDateGet (locale: 'GLOBAL' | 'US' | 'GB' | 'CA' | 'NL' | 'GR' | 'SP' | 'DE' | 'BE' | 'DK' | 'FI' | 'IE' | 'PT' | 'IN' | 'MX' | 'FR' | 'CN' | 'CH' | 'SE', market: 'STOCKS' | 'CRYPTO' | 'BONDS' | 'MF' | 'MMF' | 'INDICES' | 'FX', date: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/grouped/locale/{locale}/market/{market}/{date}'
            .replace('{' + 'locale' + '}', encodeURIComponent(String(locale)))
            .replace('{' + 'market' + '}', encodeURIComponent(String(market)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locale' is not null or undefined
        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'market' is not null or undefined
        if (market === null || market === undefined) {
            throw new Error('Required parameter market was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the previous day close for the specified ticker 
     * @summary Previous Close
     * @param ticker Ticker symbol of the request
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerPrevGet (ticker: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/prev'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerPrevGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get aggregates for a date range, in custom time window sizes 
     * @summary Aggregates
     * @param ticker Ticker symbol of the request
     * @param multiplier Size of the timespan multiplier
     * @param timespan Size of the time window
     * @param from From date
     * @param to To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerRangeMultiplierTimespanFromToGet (ticker: string, multiplier: number, timespan: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', from: string, to: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/range/{multiplier}/{timespan}/{from}/{to}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)))
            .replace('{' + 'multiplier' + '}', encodeURIComponent(String(multiplier)))
            .replace('{' + 'timespan' + '}', encodeURIComponent(String(timespan)))
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'multiplier' is not null or undefined
        if (multiplier === null || multiplier === undefined) {
            throw new Error('Required parameter multiplier was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'timespan' is not null or undefined
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MetaDataApiApiKeys {
    apiKey,
}

export class MetaDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MetaDataApiApiKeys, value: string) {
        (this.authentications as any)[MetaDataApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the analyst ratings of the symbol company/entity. Ratings are from current date, up to 5months into the future. 
     * @summary Symbol Analyst Ratings
     * @param symbol Symbol we want analyst ratings for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolAnalystsGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AnalystRatings;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/analysts'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolAnalystsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AnalystRatings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnalystRatings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the details of the symbol company/entity. These are important details which offer an overview of the entity. Things like name, sector, description, logo and similar companies. 
     * @summary Symbol Details
     * @param symbol Symbol we want details for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolCompanyGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Company;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/company'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolCompanyGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Company;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Company");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the historical dividends for this symbol. 
     * @summary Symbol Dividends
     * @param symbol Symbol we want details for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolDividendsGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Dividend>;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/dividends'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolDividendsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Dividend>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Dividend>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the historical earnings for a company 
     * @summary Symbol Earnings
     * @param symbol Symbol we want details for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolEarningsGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Earning>;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/earnings'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolEarningsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Earning>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Earning>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the historical financials for a company 
     * @summary Symbol Financials
     * @param symbol Symbol we want details for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolFinancialsGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Financial>;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/financials'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolFinancialsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Financial>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Financial>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get gets the endpoints that are supported for a symbol. **Note:** The `endpoints` object is key/values of the endpoint name and url. These will almost always be the same of all symbols. 
     * @summary Symbol Endpoints
     * @param symbol Symbol we want the endpoint list for. 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get news articles for this symbol. 
     * @summary Symbol News
     * @param symbol Symbol we want details for 
     * @param perpage How many items to be on each page during pagination. Max 50 
     * @param page Which page of results to return 
     * @param {*} [options] Override http request options.
     */
    public v1MetaSymbolsSymbolNewsGet (symbol: string, perpage?: number, page?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<News>;  }> {
        const localVarPath = this.basePath + '/v1/meta/symbols/{symbol}/news'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1MetaSymbolsSymbolNewsGet.');
        }

        if (perpage !== undefined) {
            localVarQueryParameters['perpage'] = ObjectSerializer.serialize(perpage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<News>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<News>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReferenceApiApiKeys {
    apiKey,
}

export class ReferenceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReferenceApiApiKeys, value: string) {
        (this.authentications as any)[ReferenceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Current status of each market 
     * @summary Market Status
     * @param {*} [options] Override http request options.
     */
    public v1MarketstatusNowGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: MarketStatus;  }> {
        const localVarPath = this.basePath + '/v1/marketstatus/now';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MarketStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MarketStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get upcoming market holidays and their open/close times 
     * @summary Market Holidays
     * @param {*} [options] Override http request options.
     */
    public v1MarketstatusUpcomingGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<MarketHoliday>;  }> {
        const localVarPath = this.basePath + '/v1/marketstatus/upcoming';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<MarketHoliday>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MarketHoliday>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of currently supported locales 
     * @summary Locales
     * @param {*} [options] Override http request options.
     */
    public v2ReferenceLocalesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/v2/reference/locales';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of currently supported markets 
     * @summary Markets
     * @param {*} [options] Override http request options.
     */
    public v2ReferenceMarketsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/v2/reference/markets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the historical splits for this symbol. 
     * @summary Splits
     * @param symbol Symbol we want details for 
     * @param {*} [options] Override http request options.
     */
    public v2ReferenceSplitsSymbolGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/v2/reference/splits/{symbol}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v2ReferenceSplitsSymbolGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2003");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Query all ticker symbols which are supported by Polygon.io. This API includes Indices, Crypto, FX, and Stocks/Equities. 
     * @summary Tickers
     * @param sort Which field to sort by.  For desc place a &#x60;-&#x60; in front of the field name.  **Example:** - &#x60;?sort&#x3D;-ticker&#x60; to sort symbols Z-A - &#x60;?sort&#x3D;type&#x60; to sort symbols by type 
     * @param type If you want the results to only container a certain type.  **Example:** - &#x60;?type&#x3D;etp&#x60; to get all ETFs - &#x60;?type&#x3D;cs&#x60; to get all Common Stock&#39;s 
     * @param market Get tickers for a specific market  **Example:** - &#x60;?market&#x3D;stocks&#x60; to get all stock tickers - &#x60;?market&#x3D;indices&#x60; to get all index tickers 
     * @param locale Get tickers for a specific region/locale  **Example:** - &#x60;?locale&#x3D;us&#x60; to get all US tickers - &#x60;?locale&#x3D;g&#x60; to get all Global tickers 
     * @param search Search the name of tickers  **Example:** - &#x60;?search&#x3D;microsoft&#x60; Search tickers for microsoft 
     * @param perpage How many items to be on each page during pagination. Max 50 
     * @param page Which page of results to return 
     * @param active Filter for only active or inactive symbols 
     * @param {*} [options] Override http request options.
     */
    public v2ReferenceTickersGet (sort?: string, type?: string, market?: 'STOCKS' | 'INDICES' | 'CRYPTO' | 'FX' | 'BONDS' | 'MF' | 'MMF', locale?: string, search?: string, perpage?: number, page?: number, active?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Symbol>;  }> {
        const localVarPath = this.basePath + '/v2/reference/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (market !== undefined) {
            localVarQueryParameters['market'] = ObjectSerializer.serialize(market, "'STOCKS' | 'INDICES' | 'CRYPTO' | 'FX' | 'BONDS' | 'MF' | 'MMF'");
        }

        if (locale !== undefined) {
            localVarQueryParameters['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (perpage !== undefined) {
            localVarQueryParameters['perpage'] = ObjectSerializer.serialize(perpage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Symbol>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Symbol>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the mapping of ticker types to descriptions / long names 
     * @summary Types Mapping
     * @param {*} [options] Override http request options.
     */
    public v2ReferenceTypesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/v2/reference/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2002");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StocksEquitiesApiApiKeys {
    apiKey,
}

export class StocksEquitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('query', 'apiKey'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StocksEquitiesApiApiKeys, value: string) {
        (this.authentications as any)[StocksEquitiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get historic quotes for a symbol. 
     * @summary Historic Quotes
     * @param symbol Symbol of the company to retrieve
     * @param date Date/Day of the historic ticks to retreive
     * @param offset Timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param limit Limit the size of response, Max 50000
     * @param {*} [options] Override http request options.
     */
    public v1HistoricQuotesSymbolDateGet (symbol: string, date: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/v1/historic/quotes/{symbol}/{date}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1HistoricQuotesSymbolDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1HistoricQuotesSymbolDateGet.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2009");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get historic trades for a symbol. 
     * @summary Historic Trades
     * @param symbol Symbol of the company to retrieve
     * @param date Date/Day of the historic ticks to retreive
     * @param offset Timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results. 
     * @param limit Limit the size of response, Max 50000
     * @param {*} [options] Override http request options.
     */
    public v1HistoricTradesSymbolDateGet (symbol: string, date: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/v1/historic/trades/{symbol}/{date}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1HistoricTradesSymbolDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1HistoricTradesSymbolDateGet.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2008");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the last quote tick for a given stock. 
     * @summary Last Quote for a Symbol
     * @param symbol Symbol of the quote to get
     * @param {*} [options] Override http request options.
     */
    public v1LastQuoteStocksSymbolGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }> {
        const localVarPath = this.basePath + '/v1/last_quote/stocks/{symbol}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1LastQuoteStocksSymbolGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20011");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the last trade for a given stock. 
     * @summary Last Trade for a Symbol
     * @param symbol Symbol of the stock to get
     * @param {*} [options] Override http request options.
     */
    public v1LastStocksSymbolGet (symbol: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }> {
        const localVarPath = this.basePath + '/v1/last/stocks/{symbol}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1LastStocksSymbolGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20010");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The mappings for conditions on trades and quotes. 
     * @summary Condition Mappings
     * @param ticktype Ticker type we want mappings for 
     * @param {*} [options] Override http request options.
     */
    public v1MetaConditionsTicktypeGet (ticktype: 'trades' | 'quotes', options: any = {}) : Promise<{ response: http.ClientResponse; body: ConditionTypeMap;  }> {
        const localVarPath = this.basePath + '/v1/meta/conditions/{ticktype}'
            .replace('{' + 'ticktype' + '}', encodeURIComponent(String(ticktype)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticktype' is not null or undefined
        if (ticktype === null || ticktype === undefined) {
            throw new Error('Required parameter ticktype was null or undefined when calling v1MetaConditionsTicktypeGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ConditionTypeMap;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConditionTypeMap");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of stock exchanges which are supported by Polygon.io 
     * @summary Exchanges
     * @param {*} [options] Override http request options.
     */
    public v1MetaExchangesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Exchange>;  }> {
        const localVarPath = this.basePath + '/v1/meta/exchanges';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Exchange>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Exchange>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the open, close and afterhours prices of a symbol on a certain date. 
     * @summary Daily Open / Close
     * @param symbol Symbol of the stock to get
     * @param date Date of the requested open/close
     * @param {*} [options] Override http request options.
     */
    public v1OpenCloseSymbolDateGet (symbol: string, date: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }> {
        const localVarPath = this.basePath + '/v1/open-close/{symbol}/{date}'
            .replace('{' + 'symbol' + '}', encodeURIComponent(String(symbol)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'symbol' is not null or undefined
        if (symbol === null || symbol === undefined) {
            throw new Error('Required parameter symbol was null or undefined when calling v1OpenCloseSymbolDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v1OpenCloseSymbolDateGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20012");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the daily OHLC for entire markets.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Grouped Daily
     * @param locale Locale of the aggregates ( See &#39;Locales&#39; API )
     * @param market Market of the aggregates ( See &#39;Markets&#39; API )
     * @param date To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsGroupedLocaleLocaleMarketMarketDateGet (locale: 'GLOBAL' | 'US' | 'GB' | 'CA' | 'NL' | 'GR' | 'SP' | 'DE' | 'BE' | 'DK' | 'FI' | 'IE' | 'PT' | 'IN' | 'MX' | 'FR' | 'CN' | 'CH' | 'SE', market: 'STOCKS' | 'CRYPTO' | 'BONDS' | 'MF' | 'MMF' | 'INDICES' | 'FX', date: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/grouped/locale/{locale}/market/{market}/{date}'
            .replace('{' + 'locale' + '}', encodeURIComponent(String(locale)))
            .replace('{' + 'market' + '}', encodeURIComponent(String(market)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'locale' is not null or undefined
        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'market' is not null or undefined
        if (market === null || market === undefined) {
            throw new Error('Required parameter market was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v2AggsGroupedLocaleLocaleMarketMarketDateGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the previous day close for the specified ticker 
     * @summary Previous Close
     * @param ticker Ticker symbol of the request
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerPrevGet (ticker: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/prev'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerPrevGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get aggregates for a date range, in custom time window sizes 
     * @summary Aggregates
     * @param ticker Ticker symbol of the request
     * @param multiplier Size of the timespan multiplier
     * @param timespan Size of the time window
     * @param from From date
     * @param to To date
     * @param unadjusted Set to true if the results should NOT be adjusted for splits. 
     * @param {*} [options] Override http request options.
     */
    public v2AggsTickerTickerRangeMultiplierTimespanFromToGet (ticker: string, multiplier: number, timespan: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', from: string, to: string, unadjusted?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AggResponse;  }> {
        const localVarPath = this.basePath + '/v2/aggs/ticker/{ticker}/range/{multiplier}/{timespan}/{from}/{to}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)))
            .replace('{' + 'multiplier' + '}', encodeURIComponent(String(multiplier)))
            .replace('{' + 'timespan' + '}', encodeURIComponent(String(timespan)))
            .replace('{' + 'from' + '}', encodeURIComponent(String(from)))
            .replace('{' + 'to' + '}', encodeURIComponent(String(to)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'multiplier' is not null or undefined
        if (multiplier === null || multiplier === undefined) {
            throw new Error('Required parameter multiplier was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'timespan' is not null or undefined
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling v2AggsTickerTickerRangeMultiplierTimespanFromToGet.');
        }

        if (unadjusted !== undefined) {
            localVarQueryParameters['unadjusted'] = ObjectSerializer.serialize(unadjusted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AggResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AggResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 gainers of the day at the moment. 
     * @summary Snapshot - Gainers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleUsMarketsStocksGainersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/us/markets/stocks/gainers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20013");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of the top 20 losers of the day at the moment. 
     * @summary Snapshot - Losers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleUsMarketsStocksLosersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/us/markets/stocks/losers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20013");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Snapshot allows you to see all tickers current minute aggregate, daily aggregate and last trade. As well as previous days aggregate and calculated change for today.  ### *** Warning, may cause browser to hang *** The response size is large, and sometimes will cause the browser prettyprint to crash. 
     * @summary Snapshot - All Tickers
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleUsMarketsStocksTickersGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/us/markets/stocks/tickers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20013");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See the current snapshot of a single ticker 
     * @summary Snapshot - Single Ticker
     * @param ticker Ticker of the snapshot
     * @param {*} [options] Override http request options.
     */
    public v2SnapshotLocaleUsMarketsStocksTickersTickerGet (ticker: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }> {
        const localVarPath = this.basePath + '/v2/snapshot/locale/us/markets/stocks/tickers/{ticker}'
            .replace('{' + 'ticker' + '}', encodeURIComponent(String(ticker)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ticker' is not null or undefined
        if (ticker === null || ticker === undefined) {
            throw new Error('Required parameter ticker was null or undefined when calling v2SnapshotLocaleUsMarketsStocksTickersTickerGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20014");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
